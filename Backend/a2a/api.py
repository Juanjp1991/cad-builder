"""API endpoints for the Agent-to-Agent (A2A) protocol.

This module defines the FastAPI router for handling A2A messages,
task management, and agent capabilities discovery.
"""

import os
import logging
from typing import Dict
from fastapi import APIRouter, HTTPException, BackgroundTasks, Request

from a2a.models import (
    SendMessageRequest, Task, TaskStatus, TaskState, Message, Role, Part, FilePart,
    AgentCard, MessageType, ModificationData
)
from a2a.task_manager import TaskManager
from runner import run_agent, run_modification_agent
from config import settings
from tools.cad_tools import task_id_var

logger = logging.getLogger(__name__)

router = APIRouter()
task_manager = TaskManager()

def _find_generated_files(task_id: str, output_dir: str) -> list[Part]:
    """Scans the output directory for files generated by the task.

    Args:
        task_id (str): The task identifier.
        output_dir (str): The directory to scan.

    Returns:
        list[Part]: A list of file parts found.
    """
    parts = []
    if not os.path.exists(output_dir):
        return parts

    for filename in os.listdir(output_dir):
        if not filename.startswith(task_id):
            continue
            
        if filename.endswith(".stl"):
            parts.append(Part(file=FilePart(
                file_with_uri=f"/download/{filename}",
                name=filename,
                media_type="model/stl"
            )))
        elif filename.endswith(".step"):
            parts.append(Part(file=FilePart(
                file_with_uri=f"/download/{filename}",
                name=filename,
                media_type="model/step"
            )))
    return parts

async def process_a2a_task(
    task_id: str,
    prompt: str,
    context_id: str,
    version_type: str = "generation"
) -> None:
    """Process an A2A generation task in the background.

    Uses fast-first-display: shows first model immediately, refines in background.
    Tracks all versions in ModelHistory.

    Args:
        task_id (str): The unique identifier for the task.
        prompt (str): The input prompt from the user/agent.
        context_id (str): The context or session ID.
        version_type (str): Type of version to create ("generation" or "regenerate").
    """
    from runner import run_agent_with_history

    logger.info(f"Processing A2A task {task_id} with prompt: {prompt}, type: {version_type}")
    task_manager.update_task_status(task_id, TaskState.WORKING)

    # Only create version history if it doesn't exist yet
    if not task_manager.get_history(task_id):
        task_manager.create_history(task_id, original_prompt=prompt)

    # Set the task ID in the context variable so tools can use it
    token = task_id_var.set(task_id)

    # Determine the version type to use based on whether this is initial or regenerate
    actual_version_type = version_type

    # Version callback to track each generated version
    def version_callback(
        version_prompt: str,
        callback_version_type: str,
        code: str,
        stl_path: str | None,
        png_path: str | None,
        feedback: str | None,
        approved: bool
    ):
        # Use the provided version_type for the first version, then use callback's type
        final_type = actual_version_type if callback_version_type == "generation" else callback_version_type
        task_manager.add_version(
            task_id=task_id,
            prompt=version_prompt,
            version_type=final_type,
            code=code,
            stl_path=stl_path,
            png_path=png_path,
            designer_feedback=feedback,
            approved=approved
        )
        logger.info(f"Version added to task {task_id}: type={final_type}, approved={approved}")

    # Approval callback to mark v1 as approved when Designer approves first draft
    def approval_callback(feedback: str, approved: bool):
        history = task_manager.get_history(task_id)
        if history and history.versions:
            # Update the first version's approval status
            v1_id = history.versions[0].id
            task_manager.update_version_approval(task_id, v1_id, approved, feedback)
            logger.info(f"Version {v1_id} of task {task_id} marked as approved={approved}")

    try:
        final_response = ""
        # Execute the agent workflow with history tracking
        async for response_chunk in run_agent_with_history(
            prompt=prompt,
            session_id=context_id,
            version_callback=version_callback,
            approval_callback=approval_callback
        ):
            final_response = response_chunk

        # Check for generated files in outputs/ matching the task ID
        file_parts = _find_generated_files(task_id, settings.OUTPUT_DIR)
        parts = [Part(text=final_response)] + file_parts

        response_message = Message(
            role=Role.AGENT,
            parts=parts
        )

        # Set artifacts on the task so frontend can access STL files
        from a2a.models import Artifact
        if file_parts:
            task = task_manager.get_task(task_id)
            if task:
                task.artifacts = Artifact(parts=file_parts)

        task_manager.update_task_status(task_id, TaskState.COMPLETED, response_message)

        logger.info(f"A2A generation task {task_id} completed successfully")

    except Exception as e:
        error_msg = f"Internal error during generation: {str(e)}"
        response_message = Message(
            role=Role.AGENT,
            parts=[Part(text=error_msg)]
        )
        task_manager.update_task_status(task_id, TaskState.FAILED, response_message)
        logger.error(f"A2A generation task {task_id} exception: {e}")

    finally:
        # Reset the context variable
        task_id_var.reset(token)


async def process_modification_task(
    task_id: str,
    modification_data: ModificationData,
    context_id: str
) -> None:
    """Process an A2A modification task in the background.

    Args:
        task_id (str): The unique identifier for the task.
        modification_data (ModificationData): The modification request data.
        context_id (str): The context or session ID.
    """
    # Log modification request details (truncate potentially sensitive code)
    logger.info(
        f"Processing A2A modification task {task_id} with prompt: "
        f"{modification_data.modification_prompt[:100]}..."
    )
    logger.info(
        f"Modification task {task_id}: base_model_id={modification_data.base_model_id}, "
        f"base_code_length={len(modification_data.base_code)} chars"
    )

    task_manager.update_task_status(task_id, TaskState.WORKING)

    # Set the task ID in the context variable so tools can use it
    token = task_id_var.set(task_id)

    try:
        final_response = ""
        # Convert inventory to list of dicts if present
        inventory_list = None
        if modification_data.inventory:
            inventory_list = [
                {"size": b.size, "color": b.color, "count": b.count}
                for b in modification_data.inventory
            ]

        # Execute the modification agent workflow via Runner
        async for response_chunk in run_modification_agent(
            existing_code=modification_data.base_code,
            modification_prompt=modification_data.modification_prompt,
            session_id=context_id,
            inventory=inventory_list
        ):
            final_response = response_chunk

        # Check for generated files in outputs/ matching the task ID
        file_parts = _find_generated_files(task_id, settings.OUTPUT_DIR)
        parts = [Part(text=final_response)] + file_parts

        response_message = Message(
            role=Role.AGENT,
            parts=parts
        )

        # Set artifacts on the task so frontend can access STL files
        from a2a.models import Artifact
        if file_parts:
            task = task_manager.get_task(task_id)
            if task:
                task.artifacts = Artifact(parts=file_parts)

        task_manager.update_task_status(task_id, TaskState.COMPLETED, response_message)

        logger.info(f"A2A modification task {task_id} completed successfully")

    except Exception as e:
        error_msg = f"Modification not possible. Try rephrasing or use regenerate. Error: {str(e)}"
        response_message = Message(
            role=Role.AGENT,
            parts=[Part(text=error_msg)]
        )
        task_manager.update_task_status(task_id, TaskState.FAILED, response_message)
        logger.error(f"A2A modification task {task_id} exception: {e}")

    finally:
        # Reset the context variable
        task_id_var.reset(token)

@router.post("/v1/message:send")
async def a2a_send_message(request: SendMessageRequest, background_tasks: BackgroundTasks) -> Dict[str, Task]:
    """Handle incoming A2A messages and start a background task.

    Supports both generation (text_to_lego, image_to_lego) and modification
    (modify_lego_model) message types.

    Args:
        request (SendMessageRequest): The incoming message request.
        background_tasks (BackgroundTasks): FastAPI background tasks handler.

    Returns:
        Dict[str, Task]: A dictionary containing the created task.

    Raises:
        HTTPException: If the message content is empty or modification data is missing.
    """
    # Handle modification requests
    if request.message_type == MessageType.MODIFY_LEGO_MODEL:
        if not request.modification_data:
            raise HTTPException(
                status_code=400,
                detail="modification_data is required for modify_lego_model message type"
            )

        if not request.modification_data.base_code:
            raise HTTPException(
                status_code=400,
                detail="base_code is required for modification requests"
            )

        if not request.modification_data.modification_prompt:
            raise HTTPException(
                status_code=400,
                detail="modification_prompt is required for modification requests"
            )

        # Create Task
        task = task_manager.create_task(context_id=request.message.context_id)

        # Log modification request separately for analytics
        logger.info(
            "Modification request received",
            extra={
                "type": "modify_lego_model",
                "task_id": task.id,
                "base_model_id": request.modification_data.base_model_id,
                "modification_prompt": request.modification_data.modification_prompt[:50],
            }
        )

        # Start background processing for modification
        background_tasks.add_task(
            process_modification_task,
            task.id,
            request.modification_data,
            request.message.context_id
        )

        return {"task": task}

    # Handle generation requests (text_to_lego, image_to_lego)
    # Extract prompt from the first text part
    prompt = ""
    for part in request.message.parts:
        if part.text:
            prompt += part.text + "\n"

    if not prompt.strip():
        raise HTTPException(status_code=400, detail="No text content found in message")

    # Create Task
    task = task_manager.create_task(context_id=request.message.context_id)

    # Log generation request for analytics
    logger.info(
        "Generation request received",
        extra={
            "type": str(request.message_type),
            "task_id": task.id,
            "prompt": prompt[:50],
        }
    )

    # Start background processing
    background_tasks.add_task(process_a2a_task, task.id, prompt.strip(), request.message.context_id)

    return {"task": task}

@router.get("/v1/tasks/{id}")
async def a2a_get_task(id: str) -> Dict[str, Task]:
    """Retrieve the status of a specific task.

    Args:
        id (str): The task identifier.

    Returns:
        Dict[str, Task]: A dictionary containing the task details.

    Raises:
        HTTPException: If the task is not found.
    """
    task = task_manager.get_task(id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return {"task": task}

@router.get("/v1/extendedAgentCard")
async def a2a_get_agent_card(request: Request) -> AgentCard:
    """Provide the extended agent card describing capabilities.

    Args:
        request (Request): The incoming HTTP request.

    Returns:
        AgentCard: The agent card object.
    """
    base_url = str(request.base_url).rstrip("/")
    return AgentCard(
        identity={
            "name": "FormaAI 3D Agent",
            "description": "Generates and modifies 3D LEGO models (STL/STEP) from natural language descriptions using build123d and Gemini 3 Pro.",
            "author": "FormaAI Team",
            "license": "Apache-2.0"
        },
        capabilities={
            "input_types": ["text/plain", "application/json"],
            "output_types": ["model/stl", "model/step", "text/x-python"],
            "models": ["gemini-3-pro-preview"],
            "message_types": ["text_to_lego", "image_to_lego", "modify_lego_model"],
            "supports_modification": True
        },
        supported_interfaces=[
            {
                "transport": "http",
                "url": f"{base_url}/v1/message:send"
            }
        ]
    )

@router.get("/.well-known/agent-card.json")
async def a2a_well_known_card(request: Request) -> AgentCard:
    """Serve the well-known agent card for discovery.

    Args:
        request (Request): The incoming HTTP request.

    Returns:
        AgentCard: The agent card object.
    """
    return await a2a_get_agent_card(request)


# --- Version History Endpoints ---

@router.get("/v1/tasks/{id}/history")
async def a2a_get_task_history(id: str) -> Dict:
    """Retrieve version history for a task.

    Args:
        id (str): The task identifier.

    Returns:
        Dict: A dictionary containing the version history.

    Raises:
        HTTPException: If the task or history is not found.
    """
    task = task_manager.get_task(id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    history = task_manager.get_history(id)
    if not history:
        # Return empty history if none exists yet
        return {"history": {"project_id": id, "versions": [], "current_version_id": None}}

    return {"history": history}


@router.post("/v1/tasks/{id}/regenerate")
async def a2a_regenerate(id: str, background_tasks: BackgroundTasks) -> Dict[str, Task]:
    """Regenerate the model using the current version's prompt.

    Creates a new version with the same prompt, leveraging LLM randomness
    to produce a different result.

    Args:
        id (str): The task identifier.
        background_tasks (BackgroundTasks): FastAPI background tasks handler.

    Returns:
        Dict[str, Task]: A dictionary containing the task with updated status.

    Raises:
        HTTPException: If the task or history is not found.
    """
    task = task_manager.get_task(id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    history = task_manager.get_history(id)
    if not history:
        raise HTTPException(status_code=404, detail="No version history found for this task")

    current_version = history.get_current_version()
    if not current_version:
        raise HTTPException(status_code=400, detail="No current version to regenerate from")

    # Get the prompt to regenerate
    prompt = current_version.prompt

    logger.info(
        f"Regenerating task {id} with prompt: {prompt[:50]}...",
        extra={"type": "regenerate", "task_id": id}
    )

    # Update task status and start regeneration in background
    task_manager.update_task_status(id, TaskState.WORKING)
    
    # Create a NEW session for regeneration to avoid LLM caching previous response
    import uuid
    new_session_id = f"{id}_regen_{uuid.uuid4().hex[:8]}"
    
    background_tasks.add_task(process_a2a_task, id, prompt, new_session_id, "regenerate")

    return {"task": task}


@router.post("/v1/tasks/{id}/set-version")
async def a2a_set_version(id: str, version_id: str) -> Dict:
    """Switch to a different version for viewing.

    Args:
        id (str): The task identifier.
        version_id (str): The version ID to switch to.

    Returns:
        Dict: Success status and current version info.

    Raises:
        HTTPException: If the task, history, or version is not found.
    """
    task = task_manager.get_task(id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    success = task_manager.set_current_version(id, version_id)
    if not success:
        raise HTTPException(status_code=404, detail="Version not found")

    history = task_manager.get_history(id)
    current_version = history.get_current_version() if history else None

    # Update task artifacts to point to current version's files
    if current_version and current_version.stl_path:
        from a2a.models import Artifact
        stl_filename = os.path.basename(current_version.stl_path)
        parts = [Part(file=FilePart(
            file_with_uri=f"/download/{stl_filename}",
            name=stl_filename,
            media_type="model/stl"
        ))]
        if current_version.step_path:
            step_filename = os.path.basename(current_version.step_path)
            parts.append(Part(file=FilePart(
                file_with_uri=f"/download/{step_filename}",
                name=step_filename,
                media_type="model/step"
            )))
        task.artifacts = Artifact(parts=parts)

    return {
        "success": True,
        "current_version_id": version_id,
        "current_version": current_version
    }

